# Single Param Parallel 2017: runs simulations and analyzes for bistability/resettability
# on parameters from parameters2017.csv (generated by Generate2017Params.py).
# Requires SMI2017.py run to initialize csv.

import csv
import datetime
from scipy.integrate import odeint
from joblib import Parallel, delayed
import numpy as np
import pandas as pd


# Michaelis-Menten template

def mm(num_k, num_con, denom_K, denom_con):
    val = (num_k * num_con) / (denom_K + denom_con)
    
    return val


# Chunk parameters for parallel processing

def df_chunker(full_df, chunks):
    dfs = list()
    interval_size = full_df.shape[0]//chunks
    dfs.append(full_df.iloc[0:interval_size, :])

    for i in range(chunks - 1):
        dfs.append(full_df.iloc[(interval_size * (i + 1)):(interval_size * (i + 2)), :])

    if depth_params.shape[0] % chunks != 0:
        dfs.append(full_df.iloc[interval_size * chunks: , :])

    return dfs


# Performs analysis on switch/bistability behavior.
# Need to implement resettability condition in the future.
# E2F_on, E2F_off: proliferative and quiescent odeint outputs, respectively.

def cond_analysis(E2F_on, E2F_off):
    lmda = 0.1
    # Calculate difference between max and min of SS for EE-off initial condition
    EE_min_max = max(E2F_off) - min(E2F_off)

    # Switch conditions
    switch = False
    if EE_min_max > lmda:
        switch = True

    # Keep record of delta EE_SS
    delta_EE_SS = []
    for SS_off, SS_on in zip(E2F_off, E2F_on):
        delta_EE_SS.append(SS_on - SS_off)
        
    # Bistability conditions
    bistable_bool = False
    if sum([i > EE_min_max * .1 for i in delta_EE_SS]) >= 2 and switch:
        bistable_bool = True
    elif sum([i > EE_min_max * .2 for i in delta_EE_SS]) >= 1 and switch:
        bistable_bool = True
    
    # Resettability conditions
    reset_bool = False
    if delta_EE_SS[0] <= .05:
        reset_bool = True
    
    # Assess if both resettable and bistable
    rebi_bool = 0
    if reset_bool and bistable_bool: 
        rebi_bool = 1
    
    return rebi_bool, int(bistable_bool)


def systems(X, t, S):
    # ODEs as vector elements
    M = X[0]
    CD = X[1]
    CE = X[2]
    E = X[3]
    R = X[4]
    RP = X[5]
    RE = X[6]
    I = X[7]
    
    kKpP1 = k_P1 / (K_P1 + I)
    kKpP2 = k_P2 / (K_P2 + I)
        
    dMdt = mm(k_M, S, K_S, S) - (d_M * M)
    dCDdt = mm(k_CD, M, K_M, M) + mm(k_CDS, S, K_S, S) - d_CD * CD
    dCEdt = mm(k_CE, E, K_E, E) - (d_CE * CE)
    dEdt = mm(kKpP1, CD * RE, K_CD, RE) + mm(kKpP2, CE * RE, K_CE, RE) + mm(k_E, M, K_M, M) * mm(1, E, K_E, E) + mm(k_b, M, K_M, M) - (d_E * E) - (k_RE * R * E)
    dRdt = k_R + mm(k_DP, RP, K_RP, RP) - mm(kKpP1, CD * R, K_CD, R) - mm(kKpP2, CE * R, K_CE, R) - (d_R * R) - (k_RE * R * E)
    dRPdt = mm(kKpP1, CD * R, K_CD, R) + mm(kKpP2, CE * R, K_CE, R) + mm(kKpP1, CD * RE, K_CD, RE) + mm(kKpP2, CE * RE, K_CE, RE) - mm(k_DP, RP, K_RP, RP) - (d_RP * RP)
    dREdt = (k_RE * R * E) - mm(kKpP1, CD * RE, K_CD, RE) - mm(kKpP2, CE * RE, K_CE, RE) - (d_RE * RE)
    dIdt = k_I - (d_I * I)
        
    return [dMdt, dCDdt, dCEdt, dEdt, dRdt, dRPdt, dREdt, dIdt]


def run_sim(param_subset):
    # Loop through parameters and record steady-state concentrations
    for i in range(param_subset.shape[0]):
        # Update parameters from row of df
        globals().update(param_subset.iloc[i].to_dict())
        
        set_dict = param_subset.iloc[i].to_dict()
        row_vals = list(set_dict.values())
        
        # Load base parameters for E2F on initial conditions
        X0_on = list(odeint(systems, X0_off, t, args=(20,))[-1])
        
        E2F_on = []
        E2F_off = []

        for S in serum_con:
            # Calculate ODEs
            psol = odeint(systems, X0_on, t, args=(S,))
            qsol = odeint(systems, X0_off, t, args=(S,))

            # Per-parameter-set steady state recording
            E2F_on.append(psol[-1, 3])
            E2F_off.append(qsol[-1, 3])

        rebi_bool, bistable_bool = cond_analysis(E2F_on, E2F_off)

        # Note that the order is bistable -> rebi
        if bistable_bool == 1:
            row_vals.append(1)
        else:
            row_vals.append(0)

        if rebi_bool == 1:
            row_vals.append(1)
        else:
            row_vals.append(0)
            
        with open("results2017.csv", 'a+', newline='') as file:
            csv_writer = csv.writer(file)
            csv_writer.writerow(row_vals)


# Parallelized simulation running

def run_parallel(params, chunks):
    dfs = df_chunker(params, chunks)
    results = Parallel(n_jobs=-1)(delayed(run_sim)(sub_df) for sub_df in dfs)
    

if __name__ == "__main__":
    # Load parameters
    params = pd.read_csv("parameters2017.csv")

    # Time steps
    hours = 200
    t = np.linspace(0, hours, num=100)

    # initial conditions
    X0_off = [0, 0, 0, 0, 0, 0, .55, .5]


    # Serum levels
    serum_con = np.linspace(0.02, 20, 100)
    
    chunks = 96
    
    # Log start of run
    with open("runs.log", "a") as log:
        log.write(f"{datetime.datetime.now()}, searching for bistability with 2017 model.\n")
    
    run_parallel(params, chunks=chunks)
    
    # Log start of run
    with open("runs.log", "a") as log:
        log.write(f"{datetime.datetime.now()}, searching for bistability with 2017 model completed.\n")
